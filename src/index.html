<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Spotify Random Song Playlist</title>
    <link
      href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css"
      rel="stylesheet"
    />
  </head>

  <body class="font-sans bg-gray-100 p-10">
    <div id="app" class="flex flex-col items-center justify-center text-center">
      <h1 class="mb-6 text-4xl font-bold">Spotify Random Track Playlist</h1>
      <p class="mb-6 text-xl">
        Adds a selection of random tracks to a playlist called "Random Songs
        from All of Spotify" (will be created if it doesn't exist).
      </p>
      <p class="mb-6 text-lg">
        Methodology: Searches for a random year between 1860 (year of oldest
        sound recording*) and the current year and chooses a track dated that
        year, per Spotify, based on a random section of the results (up to the
        one thousand and first result, from pages randomly containing 1 to 50
        results, varying per search). The limits are Spotify's, the
        randomization here chosen to mitigate them. This search will find
        anything Spotify considers a track, so not necessarily only songs, but
        no audiobooks as such or podcasts. If an API limit is hit during running
        then fewer songs than requested may actually be added. Does not check
        against the existing playlist for duplicate tracks, but this app won't
        add more than one instance of the same track while running.
      </p>
      <p class="mb-6 text-lg">
        A third-party test suggests Spotify allows ~180 API requests per minute,
        but there also seems to be a broader limit on top of that (e.g. total
        calls within x minutes). If an error happens try waiting a little and
        maybe consider reducing the number of songs to be added (generally runs
        better on smaller batches). Unexplained errors are probably due to
        hitting API limits (Code 429).
      </p>

      <p class="mb-6 text-lg">
        1 track search = 1 request, plus retries for unsuccesful searches and at
        least one request each time your library is searched for the playlist to
        be added to or made. Spotify searches up to fifty at a time, so if your
        playlist is further down in your library the API will be called multiple
        times to find it.
      </p>
      <p class="mb-6 text-lg">
        *Unclear if anything that old is actually on Spotify under its original
        release date.
      </p>
      <div class="mb-4 flex flex-col items-center justify-center" id="buttons">
        <label for="numberOfSongs" class="block mb-2 text-lg"
          >Number of Tracks:</label
        >
        <input
          type="number"
          id="numberOfSongs"
          min="1"
          value="23"
          class="w-16 p-2 text-lg border border-gray-300 rounded"
        />
      </div>
      <div class="flex flex-col items-center justify-center">
        <button
          id="createPlaylistAndAddTracksButton"
          class="mb-4 px-6 py-3 bg-green-500 text-white rounded cursor-pointer text-xl hover:bg-green-600"
        >
          Create Playlist and/or Add Tracks
        </button>

        <button
          id="copyResultsButton"
          class="px-6 py-3 bg-blue-500 text-white rounded cursor-pointer text-lg hover:bg-blue-600"
        >
          Results (click to copy to clipboard)
        </button>

        <div
          id="added-songs"
          class="mt-8 max-w-screen-xl text-lg p-4 border border-gray-300 max-h-52 overflow-y-auto"
        ></div>

        <div
          id="console"
          class="hidden h-40 overflow-y-auto border-1 border-gray-300 p-4 mt-4 text-lg"
        ></div>
      </div>
    </div>

    <script>
      const CLIENT_ID = "a34e83c02f6e439a891f4c2f6ba197fe";
      const REDIRECT_URI = "https://spotify-topaz-nine.vercel.app/";
      const SCOPES =
        "playlist-modify-public playlist-modify-private playlist-read-private";

      const numberOfSongs = parseInt(
        document.getElementById("numberOfSongs").value
      );
      const searchDelay = 75;
      let playlistTracks = [];

      const addedSongsDiv = document.getElementById("added-songs");
      const consoleDiv = document.getElementById("console");

      const isAuthenticated = () => {
        const params = new URLSearchParams(window.location.hash.substring(1));
        return params.has("access_token");
      };

      const redirectToAuthorization = () => {
        window.location.href = `https://accounts.spotify.com/authorize?client_id=${CLIENT_ID}&redirect_uri=${encodeURIComponent(
          REDIRECT_URI
        )}&scope=${encodeURIComponent(SCOPES)}&response_type=token`;
      };

      const getRandomYear = () => {
        const currentYear = new Date().getFullYear();
        return Math.floor(Math.random() * (currentYear - 1860 + 1)) + 1860;
      };

      const getRandomOffset = () => {
        return Math.floor(Math.random() * 1001);
      };

      const getRandomLimit = () => {
        return Math.floor(Math.random() * 50) + 1;
      };

      const searchTrackAndAddToPlaylist = async (
        accessToken,
        playlistUrl,
        addedSongs
      ) => {
        // Ensure addedSongs is initialized as an array
        if (!Array.isArray(addedSongs)) {
          addedSongs = [];
        }

        const maxRetries = numberOfSongs * 10;
        let retryCount = 0;
        let success = false;

        while (!success && retryCount < maxRetries) {
          const randomYear = getRandomYear();
          const randomOffset = getRandomOffset();
          const randomLimit = getRandomLimit();

          const searchUrl = `https://api.spotify.com/v1/search?type=track&q=year:${randomYear}&offset=${randomOffset}&limit=${randomLimit}`;

          try {
            const response = await fetch(searchUrl, {
              headers: {
                Authorization: `Bearer ${accessToken}`,
              },
            });

            if (!response.ok) {
              throw new Error(
                `Invalid search for year ${randomYear}: ${response.statusText}`
              );
            }

            const data = await response.json();
            const tracks = data.tracks.items;

            if (tracks.length > 0) {
              const track = tracks[0];
              const trackUri = track.uri;

              // Check if the track URI is already in the playlist
              const trackInPlaylist = playlistTracks.some(
                (playlistTrack) => playlistTrack.uri === trackUri
              );

              if (trackInPlaylist) {
                console.log(
                  `Track from ${randomYear} is already in the playlist. Skipping.`
                );
                logToConsole(
                  `Track from ${randomYear} is already in the playlist. Skipping.`
                );
                return;
              }

              const addResponse = await fetch(playlistUrl, {
                method: "POST",
                headers: {
                  Authorization: `Bearer ${accessToken}`,
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({
                  uris: [trackUri],
                }),
              });

              if (addResponse.ok) {
                const trackInfo = {
                  year: randomYear,
                  name: track.name,
                  artist: track.artists.map((artist) => artist.name).join(", "),
                  uri: trackUri,
                };
                addedSongs.push(trackInfo);
                console.log(`Track from ${randomYear} found`);
                logToConsole(`Track from ${randomYear} found`);
                success = true;
              } else {
                const errorMessage = `Error adding track to the playlist: ${addResponse.statusText}`;
                console.error(errorMessage);
                logToConsole(errorMessage);
              }
            } else {
              const errorMessage = `No track found for year ${randomYear}`;
              console.error(errorMessage);
              logToConsole(errorMessage);
            }
          } catch (error) {
            const errorMessage = `Error searching for track: ${error.message}`;
            console.error(errorMessage);
            logToConsole(errorMessage);
          }

          if (!success) {
            retryCount++;
            // Introduce a delay (e.g., 2 seconds) between retries
            await new Promise((resolve) => setTimeout(resolve, searchDelay));
          }
        }
      };
      const addTracksToPlaylist = async (
        accessToken,
        playlistId,
        numberOfSongs
      ) => {
        const playlistUrl = `https://api.spotify.com/v1/playlists/${playlistId}/tracks`;
        const addedSongs = [];

        // Search and add tracks until the desired number is reached
        while (addedSongs.length < numberOfSongs) {
          const randomYear = getRandomYear();
          await searchTrackAndAddToPlaylist(
            accessToken,
            playlistUrl,
            randomYear,
            addedSongs
          );

          // Introduce a delay between requests
          await new Promise((resolve) => setTimeout(resolve, searchDelay));
        }

        // Log the songs that are going to be batched
        console.log("Songs to be batched:", addedSongs);

        // Create a batch of up to 100 tracks
        const batch = addedSongs.slice(0, 100);

        // Add the batch to the playlist
        if (batch.length > 0) {
          const uris = batch.map((song) => song.uri);
          try {
            const addResponse = await fetch(playlistUrl, {
              method: "POST",
              headers: {
                Authorization: `Bearer ${accessToken}`,
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                uris: uris,
              }),
            });

            if (addResponse.ok) {
              console.log(
                `Batch of ${uris.length} tracks added to playlist successfully`
              );
            } else {
              const errorMessage = `Error adding batch to the playlist: ${addResponse.statusText}`;
              console.error(errorMessage);
              logToConsole(errorMessage);
              // Handle error if needed
            }
          } catch (error) {
            const errorMessage = `Error adding batch to the playlist: ${error.message}`;
            console.error(errorMessage);
            logToConsole(errorMessage);
            // Handle error if needed
          }
        }

        // Display added songs information
        displayAddedSongsInfo(addedSongs);
      };
      const displayAddedSongsInfo = (addedSongs) => {
        const uniqueAddedSongs = [];
        const uniqueUris = new Set();
        addedSongs.forEach((song) => {
          if (!uniqueUris.has(song.uri)) {
            uniqueUris.add(song.uri);
            uniqueAddedSongs.push(song);
          }
        });

        addedSongsDiv.innerHTML += `<p><strong>Added Songs: ${uniqueAddedSongs.length}</strong></p>`;

        uniqueAddedSongs.forEach((song) => {
          addedSongsDiv.innerHTML += `<p>${song.year}: ${song.artist} - ${song.name} (${song.uri})</p>`;
        });

        // Scroll to the bottom to show the latest added songs
        addedSongsDiv.scrollTop = addedSongsDiv.scrollHeight;
      };

      const getPlaylistTracks = async (accessToken, playlistTracksUrl) => {
        try {
          const response = await fetch(playlistTracksUrl, {
            headers: {
              Authorization: `Bearer ${accessToken}`,
            },
          });

          if (!response.ok) {
            throw new Error(
              "Error fetching playlist tracks: " +
                response.status +
                " " +
                response.statusText
            );
          }

          const data = await response.json();
          return data.items;
        } catch (error) {
          console.error("Error fetching playlist tracks:", error);
          throw error;
        }
      };

      const searchPlaylist = async (accessToken, playlistName) => {
        let offset = 0;
        let playlist = null;

        try {
          while (!playlist) {
            const searchUrl = `https://api.spotify.com/v1/me/playlists?limit=50&offset=${offset}`;

            console.log("Searching playlists at offset", offset);

            const response = await fetch(searchUrl, {
              headers: {
                Authorization: `Bearer ${accessToken}`,
              },
            });

            console.log("Received response:", response);

            if (!response.ok) {
              throw new Error(
                "Error fetching playlists : " +
                  response.status +
                  " " +
                  response.statusText
              );
            }

            const data = await response.json();

            console.log("Received JSON data:", data);

            playlist = data.items.find((item) => item.name === playlistName);

            if (!playlist && data.next) {
              offset += 50;
              await new Promise((resolve) => setTimeout(resolve, searchDelay));
            } else {
              break;
            }
          }

          if (playlist) {
            // Fetch and store the playlist tracks once
            playlistTracks = await getPlaylistTracks(
              accessToken,
              playlist.tracks.href
            );
          }

          console.log("Found playlist:", playlist);
          return playlist;
        } catch (error) {
          console.error("Error searching playlist:", error);
          alert("An error occurred while searching for the playlist: " + error);
          throw error;
        }
      };

      const createPlaylist = async (accessToken) => {
        const createPlaylistUrl = "https://api.spotify.com/v1/me/playlists";

        const response = await fetch(createPlaylistUrl, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${accessToken}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            name: "Random Songs from All of Spotify",
            public: true,
          }),
        });

        const data = await response.json();
        return data;
      };

      const createPlaylistAndAddTracks = async () => {
        if (!isAuthenticated()) {
          redirectToAuthorization();
          return;
        }

        const params = new URLSearchParams(window.location.hash.substring(1));
        const accessToken = params.get("access_token");

        // Notify the user that the process is running
        alert(
          "This may take a minute. Close this alert to begin, and then leave this page open."
        );

        try {
          const playlist = await searchPlaylist(
            accessToken,
            "Random Songs from All of Spotify"
          );
          const playlistId = playlist
            ? playlist.id
            : (await createPlaylist(accessToken)).id;

          await addTracksToPlaylist(accessToken, playlistId, numberOfSongs);
        } catch (error) {
          console.error("An error occurred:", error);
          alert("An error occurred: " + error.message);
        } finally {
          alert("Done running.");
        }
      };

      document.addEventListener("DOMContentLoaded", () => {
        if (!isAuthenticated()) {
          redirectToAuthorization();
        }
      });

      const button = document.getElementById(
        "createPlaylistAndAddTracksButton"
      );
      if (button) {
        button.addEventListener("click", createPlaylistAndAddTracks);
      } else {
        console.error(
          'Button with id "createPlaylistAndAddTracksButton" not found.'
        );
      }

      const logToConsole = (message) => {
        console.log(message); // Log to the browser console
        consoleDiv.innerHTML += `<p>${message}</p>`;
        consoleDiv.scrollTop = consoleDiv.scrollHeight;
      };

      // Copy results to clipboard when the button is clicked
      const copyResultsButton = document.getElementById("copyResultsButton");
      copyResultsButton.addEventListener("click", () => {
        const addedSongsDiv = document.getElementById("added-songs");
        const textToCopy = addedSongsDiv.innerText;

        const tempTextarea = document.createElement("textarea");
        tempTextarea.value = textToCopy;
        document.body.appendChild(tempTextarea);
        tempTextarea.select();
        document.execCommand("copy");
        document.body.removeChild(tempTextarea);
      });
    </script>
  </body>
</html>
