<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Spotify Random Song Playlist</title>
    <link
      href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css"
      rel="stylesheet"
    />
  </head>

  <body class="font-sans bg-black text-white p-4 md:p-10">
    <div id="app" class="flex flex-col items-center justify-center text-center">
      <h1 class="mb-4 sm:mb-6 text-2xl sm:text-4xl font-bold text-green-400">
        Spotify Random Track Playlist
      </h1>

      <p class="font-bold mb-4 sm:mb-6 text-sm sm:text-xl text-left">
        Adds 25 random, non-duplicate tracks to a playlist called "Random Songs
        from All of Spotify" (will be created if it doesn't exist).
      </p>
      <p class="mb-4 sm:mb-6 text-xs sm:text-lg text-left">
        Leave this page open while running - may take a minute.
      </p>
      <p class="mb-4 sm:mb-6 text-xs sm:text-lg text-left">
        Searches a random year between 1860 (oldest known recording) and the
        current year, and/or a random character each on track title and/or
        artist. Will find anything Spotify considers a track, so not necessarily
        songs but possibly noise or spoken word, but no podcast episodes. If an
        API limit is hit during running then fewer songs than requested may
        actually be added - unexplained errors are probably due to hitting API
        limits (Code 429), check console for details and/or wait a little before
        trying again.
      </p>

      <div class="flex flex-col items-center justify-center">
        <button
          id="loginButton"
          class="px-4 py-2 mb-4 bg-green-400 text-white rounded cursor-pointer text-base sm:text-lg hover:bg-green-600"
        >
          Log In to Spotify
        </button>

        <div
          id="buttons-container"
          class="hidden flex flex-col items-center justify-center"
        >
          <div class="exclusions">
            Optional filters - not comprehensive and will marginally limit other
            tracks as well:<br />
            <input type="checkbox" id="audiobooksCheckbox" />
            <label for="audiobooksCheckbox">Fewer audiobook chapters </label>
            <input type="checkbox" id="classicalCheckbox" />
            <label for="classicalCheckbox">Less Classical </label>
            <input type="checkbox" id="nineteenHundredsCheckbox" />
            <label for="nineteenHundredsCheckbox"
              >Fewer pre-2000 releases
            </label>
            <input type="checkbox" id="eighteenHundredsCheckbox" />
            <label for="eighteenHundredsCheckbox"
              >Fewer pre-1900 releases
            </label>
          </div>
          <button
            id="createPlaylistAndAddTracksButton"
            class="mt-4 mb-4 px-4 py-2 bg-purple-600 text-white rounded cursor-pointer text-base sm:text-lg hover:bg-purple-700"
          >
            Create Playlist and/or Add Tracks
          </button>

          <button
            id="copyResultsButton"
            class="px-4 py-2 bg-blue-500 text-white rounded cursor-pointer text-sm sm:text-lg hover:bg-blue-600"
          >
            Results (click to copy to clipboard)
          </button>
        </div>

        <div
          id="added-songs"
          class="hidden mt-4 max-w-screen-md text-sm sm:text-lg p-2 border border-gray-300 max-h-52 overflow-y-auto"
        ></div>

        <!-- This div element mirrors some of the console output. Hidden by default. -->
        <div
          id="console-div"
          class="hidden mt-4 max-w-screen-md text-sm sm:text-lg p-2 border border-gray-300 max-h-52 overflow-y-auto"
        >
          Progress
        </div>
      </div>
    </div>
    <script>
      const CLIENT_ID = "a34e83c02f6e439a891f4c2f6ba197fe";
      const REDIRECT_URI = "https://spotify-topaz-nine.vercel.app/";
      const SCOPES =
        "user-read-private user-read-email user-library-read playlist-read-private playlist-modify-public playlist-modify-private";
      const NUMBER_OF_SONGS = 25;
      const BATCH_SIZE = 100; // 100 is the max songs that can be added at once per Spotify's Web API
      let earliestReleaseYear = 1860;

      const searchDelay = 200;
      let allQueriesAndTracks = [];
      let songsFound = 0;
      const trackTitleStringsToExclude = [];
      const bookTitles = [
        "Chapter \\d+", // English
        "Chapitre \\d+", // French
        "Capítulo \\d+", // Spanish
        "Kapitel \\d+", // German
        "Capitolo \\d+", // Italian
        "Capítulo \\d+", // Portuguese
        "Hoofdstuk \\d+", // Dutch
        "Kapitel \\d+", // Swedish
        "Kapittel \\d+", // Norwegian
        "Kapitel \\d+", // Danish
        "Luku \\d+", // Finnish
        "Глава \\d+", // Russian
        "Rozdział \\d+", // Polish
        "Κεφάλαιο \\d+", // Greek
        "Fejezet \\d+", // Hungarian
        "Kapitola \\d+", // Czech
        "Kapitola \\d+", // Slovak
        "del\\d+",
      ];
      const classicalTitles = [
        "Opus \\d+",
        "Op. \\d+",
        "Op \\d+",
        "Opus No",
        "Op No",
        "Op. No",
        "Opus Num",
        "Op. Num",
        "Op Num",
        // "K. \\d+",
        // "K \\d+",
        // "KV \\d+",
        // "BWV \\d+",
        // "Köchel \\d+",
        // "HWV \\d+",
        // "D. \\d+",
        // "D \\d+",
      ];

      const addedSongsDiv = document.getElementById("added-songs");
      const consoleDiv = document.getElementById("console-div");

      const isAuthenticated = () => {
        const params = new URLSearchParams(window.location.hash.substring(1));
        return params.has("access_token");
      };

      const redirectToAuthorization = () => {
        window.location.href = `https://accounts.spotify.com/authorize?client_id=${CLIENT_ID}&redirect_uri=${encodeURIComponent(
          REDIRECT_URI
        )}&scope=${encodeURIComponent(SCOPES)}&response_type=token`;
      };
      const getRandomYear = () => {
        const currentYear = new Date().getFullYear();
        return (
          Math.floor(Math.random() * (currentYear - earliestReleaseYear + 1)) +
          earliestReleaseYear
        );
      };

      //80% chance of offset being 0. 15% chance of offset being 1. 5% chance of offset being greater.
      const getRandomOffset = () => {
        const randomNumber = Math.random();
        if (randomNumber < 0.8) {
          return 0;
        } else if (randomNumber < 0.95) {
          return 1;
        } else {
          return Math.floor(Math.random() * 999) + 2;
        }
      };

      const getRandomLimit = () => {
        return Math.floor(Math.random() * 50) + 1;
      };

      // Generates a random character from the Unicode character set.
      const getRandomCharacter = () => {
        // Define multiple ranges
        const ranges = [
          { min: 32, max: 126 }, // Basic ASCII characters
          { min: 128, max: 255 }, // Extended ASCII characters
          { min: 256, max: 383 }, // Latin Extended-A
          { min: 384, max: 591 }, // Latin Extended-B
          { min: 592, max: 687 }, // Latin Extended Additional
          { min: 688, max: 767 }, // IPA Extensions
          { min: 768, max: 879 }, // Spacing Modifier Letters
          { min: 880, max: 1023 }, // Greek and Coptic
          { min: 1024, max: 1279 }, // Cyrillic
          { min: 1280, max: 1327 }, // Armenian
          { min: 1328, max: 1423 }, // Hebrew
          { min: 1424, max: 1535 }, // Arabic
          { min: 1536, max: 1791 }, // Syriac
          { min: 1792, max: 1871 }, // Thaana
          { min: 1872, max: 1919 }, // NKo
          { min: 1920, max: 1983 }, // Samaritan
          { min: 1984, max: 2047 }, // Mandaic
          { min: 2048, max: 2111 }, // Syriac Supplement
          { min: 2112, max: 2143 }, // Arabic Extended-A
          { min: 2144, max: 2207 }, // Devanagari
          { min: 2208, max: 2303 }, // Bengali
          { min: 2304, max: 2431 }, // Gurmukhi
          { min: 2432, max: 2559 }, // Gujarati
          { min: 2560, max: 2687 }, // Oriya
          { min: 2688, max: 2815 }, // Tamil
          { min: 2816, max: 2943 }, // Telugu
          { min: 2944, max: 3071 }, // Kannada
          { min: 3072, max: 3199 }, // Malayalam
          { min: 3200, max: 3327 }, // Sinhala
          { min: 3328, max: 3455 }, // Thai
          { min: 3456, max: 3583 }, // Lao
          { min: 3584, max: 3711 }, // Tibetan
          { min: 3712, max: 3839 }, // Myanmar
          { min: 3840, max: 4095 }, // Georgian
          { min: 4096, max: 4255 }, // Hangul Jamo
          { min: 4256, max: 4351 }, // Ethiopic
          { min: 4352, max: 4607 }, // Cherokee
          { min: 4608, max: 4991 }, // Unified Canadian Aboriginal Syllabics
          { min: 4992, max: 5023 }, // Ogham
          { min: 5024, max: 5119 }, // Runic
          { min: 5120, max: 5759 }, // Khmer
          { min: 5760, max: 5791 }, // Mongolian
          { min: 5792, max: 5887 }, // Braille Patterns
          { min: 5888, max: 5919 }, // Yi Syllables
          { min: 5920, max: 5951 }, // Tagalog
          { min: 5952, max: 5983 }, // Old Italic
          { min: 5984, max: 6015 }, // Gothic
          { min: 6016, max: 6143 }, // Deseret
          { min: 6144, max: 6319 }, // Byzantine Musical Symbols
          { min: 6320, max: 6399 }, // Musical Symbols
          { min: 6400, max: 6479 }, // Ancient Greek Musical Notation
          { min: 6480, max: 6527 }, // Tai Xuan Jing Symbols
          { min: 6528, max: 6623 }, // Mathematical Alphanumeric Symbols
          { min: 6624, max: 6655 }, // CJK Unified Ideographs Extension A
          { min: 6656, max: 6687 }, // CJK Unified Ideographs
          { min: 6688, max: 6751 }, // Yi Radicals
          { min: 6752, max: 6783 }, // Vai
          { min: 6784, max: 6799 }, // Cyrillic Extended-B
          { min: 6800, max: 6911 }, // Modifier Tone Letters
          { min: 6912, max: 7039 }, // Latin Extended-D
          { min: 7040, max: 7103 }, // Syloti Nagri
          { min: 7104, max: 7167 }, // Common Indic Number Forms
          { min: 7168, max: 7247 }, // Phags-pa
          { min: 7248, max: 7295 }, // Saurashtra
          { min: 7296, max: 7359 }, // Devanagari Extended
          { min: 7360, max: 7375 }, // Kayah Li
          { min: 7376, max: 7423 }, // Rejang
          { min: 7424, max: 7551 }, // Hangul Jamo Extended-A
          { min: 7552, max: 7615 }, // Javanese
          { min: 7616, max: 7679 }, // Myanmar Extended-B
          { min: 7680, max: 7935 }, // Latin Extended Additional
          { min: 7936, max: 8191 }, // Greek Extended
          { min: 8192, max: 8303 }, // General Punctuation
          { min: 8304, max: 8351 }, // Superscripts and Subscripts
          { min: 8352, max: 8399 }, // Currency Symbols
          { min: 8400, max: 8447 }, // Combining Diacritical Marks for Symbols
          { min: 8448, max: 8527 }, // Letterlike Symbols
          { min: 8528, max: 8591 }, // Number Forms
          { min: 8592, max: 8703 }, // Arrows
          { min: 8704, max: 8959 }, // Mathematical Operators
          { min: 8960, max: 9215 }, // Miscellaneous Technical
          { min: 9216, max: 9279 }, // Control Pictures
          { min: 9280, max: 9311 }, // Optical Character Recognition
          { min: 9312, max: 9471 }, // Enclosed Alphanumerics
          { min: 9472, max: 9599 }, // Box Drawing
          { min: 9600, max: 9631 }, // Block Elements
          { min: 9632, max: 9727 }, // Geometric Shapes
          { min: 9728, max: 9983 }, // Miscellaneous Symbols
          { min: 9984, max: 10111 }, // Dingbat
          { min: 10112, max: 10191 }, // Miscellaneous Mathematical Symbols-A
          { min: 10192, max: 10223 }, // Supplemental Arrows-A
          { min: 10224, max: 10239 }, // Braille Patterns
          { min: 10240, max: 10495 }, // CJK Unified Ideographs Extension B
          { min: 10496, max: 10623 }, // CJK Unified Ideographs Extension C
          { min: 10624, max: 10751 }, // CJK Unified Ideographs Extension D
          { min: 10752, max: 11007 }, // CJK Compatibility Ideographs Supplement
          { min: 11008, max: 11263 }, // CJK Unified Ideographs Extension E
          { min: 11264, max: 11359 }, // CJK Unified Ideographs Extension F
          { min: 11360, max: 11391 }, // Vertical Forms
          { min: 11392, max: 11519 }, // Combining Half Marks
          { min: 11520, max: 11567 }, // CJK Compatibility Forms
          { min: 11568, max: 11647 }, // Small Form Variants
          { min: 11648, max: 11743 }, // Arabic Presentation Forms-A
          { min: 11744, max: 11775 }, // Variation Selectors
          { min: 11776, max: 11903 }, // Vertical Forms
          { min: 11904, max: 12031 }, // Combining Half Marks
          { min: 12032, max: 12255 }, // CJK Compatibility Forms
          { min: 12256, max: 12287 }, // Small Form Variants
          { min: 12288, max: 12351 }, // CJK Symbols and Punctuation
          { min: 12352, max: 12447 }, // Hiragana
          { min: 12448, max: 12543 }, // Katakana
          { min: 12544, max: 12591 }, // Bopomofo
          { min: 12592, max: 12687 }, // Hangul Compatibility Jamo
          { min: 12688, max: 12703 }, // Kanbun
          { min: 12704, max: 12735 }, // Bopomofo Extended
          { min: 12736, max: 12783 }, // CJK Strokes
          { min: 12784, max: 12799 }, // Katakana Phonetic Extensions
          { min: 12800, max: 13055 }, // Enclosed CJK Letters and Months
          { min: 13056, max: 13311 }, // CJK Compatibility
          { min: 13312, max: 19903 }, // CJK Unified Ideographs Extension G
          { min: 19904, max: 19967 }, // CJK Compatibility Ideographs
          { min: 19968, max: 40959 }, // CJK Unified Ideographs
          { min: 40960, max: 42127 }, // Yi Syllables
          { min: 42128, max: 42191 }, // Yi Radicals
          { min: 42192, max: 42239 }, // Lisu
          { min: 42240, max: 42559 }, // Vai
          { min: 42560, max: 42655 }, // Cyrillic Extended-C
          { min: 42656, max: 42751 }, // Bamum
          { min: 42752, max: 42783 }, // Modifier Tone Letters
          { min: 42784, max: 43007 }, // Latin Extended-D
          { min: 43008, max: 43055 }, // Syloti Nagri
          { min: 43056, max: 43071 }, // Common Indic Number Forms
          { min: 43072, max: 43135 }, // Phags-pa
          { min: 43136, max: 43231 }, // Saurashtra
          { min: 43232, max: 43263 }, // Devanagari Extended
          { min: 43264, max: 43311 }, // Kayah Li
          { min: 43312, max: 43359 }, // Rejang
          { min: 43360, max: 43391 }, // Hangul Jamo Extended-A
          { min: 43392, max: 43487 }, // Javanese
          { min: 43488, max: 43519 }, // Myanmar Extended-B
          { min: 43520, max: 43583 }, // Cham
          { min: 43584, max: 43599 }, // Myanmar Extended-A
          { min: 43600, max: 43647 }, // Tai Viet
          { min: 43648, max: 43743 }, // Meetei Mayek Extensions
          { min: 43744, max: 43775 }, // Ethiopic Extended-A
          { min: 43776, max: 43823 }, // Latin Extended-E
          { min: 43824, max: 43887 }, // Cherokee Supplement
          { min: 43888, max: 43967 }, // Meetei Mayek
          { min: 43968, max: 44031 }, // Hangul Syllables
          { min: 44032, max: 55215 }, // Hangul Jamo Extended-B
          { min: 55216, max: 55295 }, // High Surrogates
          { min: 55296, max: 56191 }, // High Private Use Surrogates
          { min: 56192, max: 56319 }, // Low Surrogates
          { min: 56320, max: 57343 }, // Private Use Area
          { min: 57344, max: 63743 }, // CJK Compatibility Ideographs
          { min: 63744, max: 64255 }, // Alphabetic Presentation Forms
          { min: 64256, max: 64335 }, // Arabic Presentation Forms-B
          { min: 64336, max: 65023 }, // Small Form Variants
          { min: 65024, max: 65039 }, // Combining Half Marks
          { min: 65040, max: 65055 }, // CJK Compatibility Forms
          { min: 65056, max: 65071 }, // Small Form Variants
          { min: 65072, max: 65103 }, // Alphabetic Presentation Forms
          { min: 65104, max: 65135 }, // Arabic Presentation Forms-A
          { min: 65136, max: 65279 }, // Halfwidth and Fullwidth Forms
          { min: 65280, max: 65519 }, // Specials
          { min: 65520, max: 65535 }, // Specials
        ];

        // 5% chance to select from all sets
        if (Math.random() < 0.05) {
          // Combine all ranges into a single array
          const allRanges = ranges.reduce((acc, range) => {
            for (let i = range.min; i <= range.max; i++) {
              acc.push(i);
            }
            return acc;
          }, []);

          // Randomly select a character code from all sets
          const randomCodePoint =
            allRanges[Math.floor(Math.random() * allRanges.length)];

          return String.fromCodePoint(randomCodePoint);
        } else {
          // Randomly select a range
          const randomRange = ranges[Math.floor(Math.random() * ranges.length)];

          // Randomly select a character code within the chosen range
          const randomCodePoint =
            Math.floor(
              Math.random() * (randomRange.max - randomRange.min + 1)
            ) + randomRange.min;

          return String.fromCodePoint(randomCodePoint);
        }
      };

      const searchTrackAndAddToPlaylist = async (
        accessToken,
        playlistUrl,
        addedSongs,
        addedDuringRuntime
      ) => {
        const searchCriteria = generateSearchCriteria(); // Generate search criteria for each search
        const { includeYear, randomFields, randomOffset, randomLimit } =
          searchCriteria;

        let queryString = Object.entries(randomFields)
          .map(([key, value]) => `${key}:${value}`)
          .join(" & ");

        const searchQuery = `q=${queryString}&type=track&limit=${randomLimit}&offset=${randomOffset}`;

        const searchUrl = `https://api.spotify.com/v1/search?${searchQuery}`;

        try {
          await new Promise((resolve) => setTimeout(resolve, searchDelay));

          const response = await fetch(searchUrl, {
            headers: {
              Authorization: `Bearer ${accessToken}`,
            },
          });

          if (response.status === 429) {
            console.error("Too Many Requests: Please try again later.");
            return; // Stop the function execution
          }
          if (!response.ok) {
            throw new Error(`Invalid search query: ${response.statusText}`);
          }

          const data = await response.json();
          const tracks = data.tracks.items;

          if (tracks.length > 0) {
            const randomIndex = Math.floor(Math.random() * tracks.length);
            const track = tracks[randomIndex];
            const trackUri = track.uri;
            const trackName = track.name;

            // Log details of the query and the track
            const queryDetails = {
              query: searchQuery,
              track: track,
            };
            allQueriesAndTracks.push(queryDetails);

            // Check if the track should be excluded using regular expressions
            const isExcluded = trackTitleStringsToExclude.some((titleRegex) =>
              titleRegex.test(trackName)
            );

            if (isExcluded) {
              logToConsole(
                `Track excluded for search: ${searchQuery}. Skipping.`
              );
              return null;
            }

            // Check if the track has already been added during runtime
            if (addedDuringRuntime.includes(trackUri)) {
              logToConsole(
                `Duplicate track found for search: ${searchQuery}. Skipping.`
              );

              return null;
            }

            // Check if the track is already in the playlist
            const trackInPlaylist = existingPlaylistTracks.some(
              (playlistTrack) =>
                playlistTrack.track && playlistTrack.track.uri === trackUri
            );

            if (trackInPlaylist) {
              logToConsole(
                `Duplicate track found in playlist for search: ${searchQuery}. Skipping.`
              );

              return null;
            }

            addedSongs.push({
              year: track.album.release_date.slice(0, 4),
              album: track.album.name,
              name: track.name,
              artist: track.artists.map((artist) => artist.name).join(", "),
              uri: trackUri,
            });

            addedDuringRuntime.push(...addedSongs);

            logToConsole(`Track found for search: ${searchQuery}`);
            songsFound++;
            copyResultsButton.innerText = `Finding random tracks...${songsFound}/${NUMBER_OF_SONGS}`;
            return trackUri;
          } else {
            const errorMessage = `No track found for search: ${searchQuery}`;
            console.error(errorMessage);
            return null;
          }
        } catch (error) {
          const errorMessage = `Error searching for track: ${error.message}`;
          console.error(errorMessage);
        }
      };
      const generateSearchCriteria = () => {
        const scenario = getRandomScenario();

        if (scenario === "yearOnly") {
          // Scenario C: Search based only on a random year
          const randomOffset = getRandomOffset();
          const randomLimit = getRandomLimit();

          return {
            includeYear: true,
            randomFields: {
              year: getRandomYear(),
            },
            randomOffset,
            randomLimit,
          };
        } else if (scenario === "yearWithCriteria") {
          // Scenario A: Include a random year plus additional criteria
          const randomFieldsCount = getRandomNumberInRange(1, 2); // Choose additional fields
          const randomFields = ["year", ...getRandomFields(randomFieldsCount)];
          const randomOffset = getRandomOffset();
          const randomLimit = getRandomLimit();

          const fieldsWithValues = randomFields.reduce((acc, field) => {
            if (field === "year") {
              acc[field] = getRandomYear();
            } else {
              acc[field] = getRandomCharacter();
            }
            return acc;
          }, {});

          return {
            includeYear: true,
            randomFields: fieldsWithValues,
            randomOffset,
            randomLimit,
          };
        } else {
          // Scenario B: Exclude the year and choose criteria randomly
          const randomFieldsCount = getRandomNumberInRange(1, 2); // Choose fields without the year
          const randomFields = getRandomFields(randomFieldsCount);
          const randomOffset = getRandomOffset();
          const randomLimit = getRandomLimit();

          const fieldsWithValues = randomFields.reduce((acc, field) => {
            acc[field] = getRandomCharacter();
            return acc;
          }, {});

          return {
            includeYear: false,
            randomFields: fieldsWithValues,
            randomOffset,
            randomLimit,
          };
        }
      };

      const getRandomScenario = () => {
        const scenarios = [
          "yearOnly",
          "yearWithCriteria",
          "noYearWithCriteria",
        ];
        return scenarios[Math.floor(Math.random() * scenarios.length)];
      };

      const getRandomNumberInRange = (min, max) => {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      };
      const getRandomFields = (count) => {
        const fields = ["track", "artist"];
        const randomFields = [];

        for (let i = 0; i < count; i++) {
          const randomField = fields[Math.floor(Math.random() * fields.length)];
          randomFields.push(randomField);
        }

        return randomFields;
      };
      const addTracksToPlaylist = async (
        accessToken,
        playlistId,
        numberOfSongs
      ) => {
        const playlistUrl = `https://api.spotify.com/v1/playlists/${playlistId}/tracks`;
        const addedSongs = [];
        const addedDuringRuntime = [];
        while (addedSongs.length < numberOfSongs) {
          const remainingSongs = numberOfSongs - addedSongs.length;
          const tracksToAdd = Math.min(remainingSongs, BATCH_SIZE);
          const trackBatch = [];

          for (let i = 0; i < tracksToAdd; i++) {
            let trackUri;

            // Continue searching until a valid track is found
            while (!trackUri) {
              const randomYear = getRandomYear();
              trackUri = await searchTrackAndAddToPlaylist(
                accessToken,
                playlistUrl,
                addedSongs,
                addedDuringRuntime
              );
            }

            trackBatch.push(trackUri);
          }

          // Batch addition of tracks to the playlist
          await addBatchToPlaylist(accessToken, playlistUrl, trackBatch);

          // Introduce a delay between batches to avoid rate limits
          await new Promise((resolve) => setTimeout(resolve, searchDelay));
        }

        // Display added songs information
        addedSongsDiv.classList.remove("hidden");
        displayAddedSongsInfo(addedSongs);
      };

      const addBatchToPlaylist = async (
        accessToken,
        playlistUrl,
        trackBatch
      ) => {
        copyResultsButton.innerText = `Adding tracks to playlist...`;
        try {
          let retryCount = 0;
          const maxRetries = 3; // Replace with the desired maximum number of retries

          while (retryCount < maxRetries) {
            const addResponse = await fetch(playlistUrl, {
              method: "POST",
              headers: {
                Authorization: `Bearer ${accessToken}`,
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                uris: trackBatch,
              }),
            });

            if (addResponse.ok) {
              console.log(
                `${trackBatch.length} tracks added to the playlist successfully`
              );
              return; // Exit the function if successful
            } else {
              const errorMessage = `Error adding batch to the playlist: ${addResponse.statusText}`;
              console.error(errorMessage);

              // Increment the retry count and introduce a delay before the next retry
              retryCount++;
              await new Promise((resolve) =>
                setTimeout(resolve, searchDelay * 2)
              );
            }
          }

          console.error(
            `Max retries exceeded. Failed to add batch to the playlist`
          );
          // Run an alert or handle the failure case if maximum retries exceeded
        } catch (error) {
          const errorMessage = `Error adding batch to the playlist: ${error.message}`;
          console.error(errorMessage);
          // Run an alert or handle the failure case if an error occurs
        }
      };
      const displayAddedSongsInfo = (addedSongs) => {
        addedSongsDiv.innerHTML += `<p><strong>Added Songs:</strong></p>`;

        addedSongs.forEach((song, index) => {
          const songNumber = index + 1;
          addedSongsDiv.innerHTML += `<p>${songNumber}. ${song.artist} - ${song.name} | ${song.album}, ${song.year}  (${song.uri})</p>`;
        });

        // Scroll to the bottom to show the latest added songs
        addedSongsDiv.scrollTop = addedSongsDiv.scrollHeight;
      };

      const getPlaylistTracks = async (accessToken, playlistTracksUrl) => {
        const tracksPerPage = 100; // Spotify API returns up to 100 tracks per request
        copyResultsButton.innerText = `Reading playlist tracks...`;
        logToConsole("Reading playlist tracks...");
        try {
          let offset = 0;
          let hasNextPage = true;

          while (hasNextPage) {
            const response = await fetch(
              `${playlistTracksUrl}?offset=${offset}&limit=${tracksPerPage}`,
              {
                headers: {
                  Authorization: `Bearer ${accessToken}`,
                },
              }
            );

            if (!response.ok) {
              throw new Error(
                `Error fetching playlist tracks: ${response.status} ${response.statusText}`
              );
            }

            const data = await response.json();
            const currentTracks = data.items.map((item) => item.track);

            if (currentTracks.length > 0) {
              existingPlaylistTracks.push(...currentTracks);
              offset += tracksPerPage;
            } else {
              hasNextPage = false;
            }
          }

          console.log("Existing Playlist Tracks:", existingPlaylistTracks);

          return existingPlaylistTracks;
        } catch (error) {
          console.error("Error fetching existing playlist tracks:", error);
          throw error;
        }
      };

      const searchPlaylist = async (accessToken, playlistName) => {
        let offset = 0;
        let playlist = null;
        logToConsole("Getting playlist...");
        try {
          while (!playlist) {
            const searchUrl = `https://api.spotify.com/v1/me/playlists?limit=50&offset=${offset}`;

            logToConsole(`Searching for playlists at offset ${offset}`);
            const response = await fetch(searchUrl, {
              headers: {
                Authorization: `Bearer ${accessToken}`,
              },
            });

            console.log("Received response:", response);

            if (!response.ok) {
              throw new Error(
                "Error fetching playlists: " +
                  response.status +
                  " " +
                  response.statusText
              );
            }

            const data = await response.json();
            console.log("Received JSON data:", data);

            // Add this line to log the playlists found
            console.log("Playlists found:", data.items);

            playlist = data.items.find((item) => item.name === playlistName);

            if (!playlist && data.next) {
              offset += 50;
              await new Promise((resolve) =>
                setTimeout(resolve, searchDelay / 2)
              );
            } else if (!playlist) {
              // If playlist is still not found and there are no more results
              playlist = await createPlaylist(accessToken, playlistName);
              logToConsole("Playlist not found, creating a new one.");
            } else {
              break;
            }
          }

          if (playlist) {
            // Fetch and store the playlist tracks once
            console.log("Found playlist:", playlist);
            logToConsole("Adding songs");
            await getPlaylistTracks(accessToken, playlist.tracks.href);
          }

          return playlist;
        } catch (error) {
          console.error("Error searching playlist:", error);
          alert("An error occurred while searching for the playlist: " + error);
          logToConsole("An error occurred while searching for the playlist");

          throw error;
        }
      };

      const createPlaylist = async (accessToken) => {
        const createPlaylistUrl = "https://api.spotify.com/v1/me/playlists";

        const response = await fetch(createPlaylistUrl, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${accessToken}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            name: "Random Songs from All of Spotify",
            public: true,
          }),
        });

        const data = await response.json();
        return data;
      };

      const createPlaylistAndAddTracks = async () => {
        if (!isAuthenticated()) {
          redirectToAuthorization();
          return;
        }
        const existingPlaylistTracks = [];

        const params = new URLSearchParams(window.location.hash.substring(1));
        const accessToken = params.get("access_token");

        document.getElementById(
          "createPlaylistAndAddTracksButton"
        ).disabled = true;

        const audiobooksCheckbox =
          document.getElementById("audiobooksCheckbox");
        const classicalCheckbox = document.getElementById("classicalCheckbox");
        const eighteenHundredsCheckbox = document.getElementById(
          "eighteenHundredsCheckbox"
        );
        const nineteenHundredsCheckbox = document.getElementById(
          "nineteenHundredsCheckbox"
        );

        audiobooksCheckbox.disabled = true;
        classicalCheckbox.disabled = true;
        eighteenHundredsCheckbox.disabled = true;
        nineteenHundredsCheckbox.disabled = true;

        compileExclusions();

        songsFound = 0;
        const copyResultsButton = document.getElementById("copyResultsButton");
        copyResultsButton.innerText = "Finding/creating playlist...";

        try {
          const playlist = await searchPlaylist(
            accessToken,
            "Random Songs from All of Spotify"
          );
          const playlistId = playlist
            ? playlist.id
            : (await createPlaylist(accessToken)).id;

          await addTracksToPlaylist(accessToken, playlistId, NUMBER_OF_SONGS);

          // Success: Update HTML elements
          document.getElementById("copyResultsButton").innerText =
            "Results (click to copy to clipboard)";
        } catch (error) {
          console.error("An error occurred:", error);
          alert("An error occurred: " + error.message);

          // Error: Update HTML elements
          document.getElementById("copyResultsButton").innerText =
            "Error occurred. Please try again.";
        } finally {
          // Enable the button and checkboxes
          document.getElementById(
            "createPlaylistAndAddTracksButton"
          ).disabled = false;
          audiobooksCheckbox.disabled = false;
          classicalCheckbox.disabled = false;
          eighteenHundredsCheckbox.disabled = false;
          nineteenHundredsCheckbox.disabled = false;
        }
      };

      document.addEventListener("DOMContentLoaded", () => {
        const loginButton = document.getElementById("loginButton");

        if (loginButton) {
          loginButton.addEventListener("click", () => {
            redirectToAuthorization();
          });
        } else {
          console.error('Button with id "loginButton" not found.');
        }
      });

      const updateLoginStatus = () => {
        const loginButton = document.getElementById("loginButton");
        const buttonsContainer = document.getElementById("buttons-container");

        if (loginButton && buttonsContainer) {
          if (isAuthenticated()) {
            // User is logged in
            loginButton.innerText = "Logged In";
            loginButton.disabled = true; // Optionally disable the button
            buttonsContainer.classList.remove("hidden");
          } else {
            // User is not logged in
            loginButton.innerText = "Log In to Spotify";
            loginButton.disabled = false;
            buttonsContainer.classList.add("hidden");
          }
        }
      };

      updateLoginStatus();

      const button = document.getElementById(
        "createPlaylistAndAddTracksButton"
      );
      if (button) {
        button.addEventListener("click", createPlaylistAndAddTracks);
      } else {
        console.error(
          'Button with id "createPlaylistAndAddTracksButton" not found.'
        );
      }

      //See which checkboxes are checked and update exclusions accordingly
      const compileExclusions = () => {
        if (eighteenHundredsCheckbox.checked) {
          earliestReleaseYear = 1900;
        }
        if (nineteenHundredsCheckbox.checked) {
          earliestReleaseYear = 2000;
        }
        if (audiobooksCheckbox.checked) {
          const audiobookPatterns = bookTitles.map(
            (title) => new RegExp(title, "i")
          );
          trackTitleStringsToExclude.push(...audiobookPatterns);
        }
        if (classicalCheckbox.checked) {
          const classicalPatterns = classicalTitles.map(
            (title) => new RegExp(title, "i")
          );
          trackTitleStringsToExclude.push(...classicalPatterns);
        }
        return;
      };

      const logToConsole = (message) => {
        console.log(message); // Log to the browser console
        consoleDiv.innerHTML += `<p>${message}</p>`;
      };
      const logAllQueriesAndTracks = () => {
        console.log("All Queries and Tracks:");

        // Convert allQueriesAndTracks to JSON format
        const jsonFormat = JSON.stringify(allQueriesAndTracks, null, 2);
      };
      // Copy results to clipboard when the button is clicked
      const copyResultsButton = document.getElementById("copyResultsButton");
      copyResultsButton.addEventListener("click", () => {
        const addedSongsDiv = document.getElementById("added-songs");
        const textToCopy = addedSongsDiv.innerText;

        const tempTextarea = document.createElement("textarea");
        tempTextarea.value = textToCopy;
        document.body.appendChild(tempTextarea);
        tempTextarea.select();
        document.execCommand("copy");
        document.body.removeChild(tempTextarea);
      });
    </script>
  </body>
</html>
