<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Spotify Random Song Playlist</title>
    <link
      href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css"
      rel="stylesheet"
    />
  </head>

  <body class="font-sans bg-black text-white p-4 md:p-10">
    <div id="app" class="flex flex-col items-center justify-center text-center">
      <h1 class="mb-4 sm:mb-6 text-2xl sm:text-4xl font-bold text-green-400">
        Spotify Random Track Playlist
      </h1>

      <p class="mb-4 sm:mb-6 text-sm sm:text-xl text-left">
        Adds 50 random, non-duplicate tracks to a playlist called "Random Songs
        from All of Spotify" (will be created if it doesn't exist).
      </p>

      <p class="mb-4 sm:mb-6 text-xs sm:text-lg text-left">
        Searches a random year between 1860 (oldest known recording) and the
        current year, and/or a random character each on a random combination of
        fields from track title, artist, album, ISRC, and/or genre, This search
        will find anything Spotify considers a track, so not necessarily only
        songs but possibly noise or spoken word, but no podcast episodes. If an
        API limit is hit during running then fewer songs than requested may
        actually be added - unexplained errors are probably due to hitting API
        limits (Code 429), check console for details and/or wait a little before
        trying again.
      </p>

      <div class="flex flex-col items-center justify-center">
        <button
          id="loginButton"
          class="px-4 py-2 mb-4 bg-green-400 text-white rounded cursor-pointer text-base sm:text-lg hover:bg-green-600"
        >
          Log In to Spotify
        </button>

        <div
          id="buttons-container"
          class="hidden flex flex-col items-center justify-center"
        >
          <button
            id="createPlaylistAndAddTracksButton"
            class="mb-4 px-4 py-2 bg-purple-600 text-white rounded cursor-pointer text-base sm:text-lg hover:bg-purple-700"
          >
            Create Playlist and/or Add Tracks
          </button>

          <button
            id="copyResultsButton"
            class="px-4 py-2 bg-blue-500 text-white rounded cursor-pointer text-sm sm:text-lg hover:bg-blue-600"
          >
            Results (click to copy to clipboard)
          </button>
        </div>

        <div
          id="added-songs"
          class="hidden mt-4 max-w-screen-md text-sm sm:text-lg p-2 border border-gray-300 max-h-52 overflow-y-auto"
        ></div>

        <!-- This div element mirrors some of the console output. Hidden by default. -->
        <div
          id="console-div"
          class="hidden mt-4 max-w-screen-md text-sm sm:text-lg p-2 border border-gray-300 max-h-52 overflow-y-auto"
        >
          Progress
        </div>
      </div>
    </div>
    <script>
      const CLIENT_ID = "a34e83c02f6e439a891f4c2f6ba197fe";
      const REDIRECT_URI = "https://spotify-topaz-nine.vercel.app/";
      const SCOPES =
        "user-read-private user-read-email user-library-read playlist-read-private playlist-modify-public playlist-modify-private";
      const NUMBER_OF_SONGS = 50;
      const BATCH_SIZE = 100; // 100 is the max songs that can be added at once per Spotify's Web API

      const searchDelay = 200;
      let playlistTracks = [];
      let addedDuringRuntime = [];
      let allQueriesAndTracks = [];

      const addedSongsDiv = document.getElementById("added-songs");
      const consoleDiv = document.getElementById("console-div");

      const isAuthenticated = () => {
        const params = new URLSearchParams(window.location.hash.substring(1));
        return params.has("access_token");
      };

      const redirectToAuthorization = () => {
        window.location.href = `https://accounts.spotify.com/authorize?client_id=${CLIENT_ID}&redirect_uri=${encodeURIComponent(
          REDIRECT_URI
        )}&scope=${encodeURIComponent(SCOPES)}&response_type=token`;
      };
      const getRandomYear = () => {
        const currentYear = new Date().getFullYear();
        return Math.floor(Math.random() * (currentYear - 1860 + 1)) + 1860;
      };

      const getRandomOffset = () => {
        return Math.floor(Math.random() * 1001);
      };

      const getRandomLimit = () => {
        return Math.floor(Math.random() * 50) + 1;
      };

      const getRandomCharacter = () => {
        const characters =
          "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+";
        return characters[Math.floor(Math.random() * characters.length)];
      };

      const searchTrackAndAddToPlaylist = async (
        accessToken,
        playlistUrl,
        addedSongs
      ) => {
        const maxRetries = 1000;
        let retryCount = 0;
        let success = false;
        const addedTrackUris = [];
        let trackUri;

        while (!success && retryCount < maxRetries) {
          const searchCriteria = generateSearchCriteria(); // Generate search criteria for each search
          const { includeYear, randomFields, randomOffset, randomLimit } =
            searchCriteria;

          let queryString = Object.entries(randomFields)
            .map(([key, value]) => `${key}:${encodeURIComponent(value)}`)
            .join("&");

          const searchQuery = `q=${queryString}&offset=${randomOffset}&limit=${randomLimit}`;

          const searchUrl = `https://api.spotify.com/v1/search?type=track&${searchQuery}`;

          try {
            await new Promise((resolve) => setTimeout(resolve, searchDelay));

            const response = await fetch(searchUrl, {
              headers: {
                Authorization: `Bearer ${accessToken}`,
              },
            });

            if (response.status === 429) {
              console.error("Too Many Requests: Please try again later.");
              return; // Stop the function execution
            }
            if (!response.ok) {
              throw new Error(`Invalid search query: ${response.statusText}`);
            }

            const data = await response.json();
            const tracks = data.tracks.items;

            if (tracks.length > 0) {
              const track = tracks[0];
              trackUri = track.uri;
              // Log details of the query and the track
              const queryDetails = {
                query: searchQuery,
                track: track,
              };
              allQueriesAndTracks.push(queryDetails);
              // Check if the track has already been added during runtime
              if (addedDuringRuntime.includes(trackUri)) {
                logToConsole(
                  `Duplicate Track found for search: ${searchQuery}. Skipping.`
                );

                return null;
              }

              // Check if the track is already in the playlist
              const trackInPlaylist = playlistTracks.some(
                (playlistTrack) =>
                  playlistTrack.track && playlistTrack.track.uri === trackUri
              );

              if (trackInPlaylist) {
                logToConsole(
                  `Duplicate Track found in playlist for search: ${searchQuery}. Skipping.`
                );

                return null;
              }

              addedSongs.push({
                year: track.album.release_date.slice(0, 4),
                album: track.album.name,
                name: track.name,
                artist: track.artists.map((artist) => artist.name).join(", "),
                uri: trackUri,
              });

              logToConsole(`Track found for search: ${searchQuery}`);

              return trackUri;
            } else {
              const errorMessage = `No track found for search: ${searchQuery}`;
              console.error(errorMessage);
              return null;
            }
          } catch (error) {
            const errorMessage = `Error searching for track: ${error.message}`;
            console.error(errorMessage);
          }

          if (!success) {
            addedTrackUris.push(trackUri);
            retryCount++;
            // Introduce a delay (e.g., 2 seconds) between retries
            await new Promise((resolve) => setTimeout(resolve, searchDelay));
          }
        }

        // After successfully adding a track, update the list of tracks added during runtime
        addedDuringRuntime.push(trackUri);
      };
      const generateSearchCriteria = () => {
        const scenario = getRandomScenario();

        if (scenario === "yearOnly") {
          // Scenario C: Search based only on a random year
          const randomOffset = getRandomOffset();
          const randomLimit = getRandomLimit();

          return {
            includeYear: true,
            randomFields: {
              year: getRandomYear(),
            },
            randomOffset,
            randomLimit,
          };
        } else if (scenario === "yearWithCriteria") {
          // Scenario A: Include a random year plus one or two additional criteria
          const randomFieldsCount = getRandomNumberInRange(1, 2); // Choose 1 or 2 additional fields
          const randomFields = ["year", ...getRandomFields(randomFieldsCount)];
          const randomOffset = getRandomOffset();
          const randomLimit = getRandomLimit();

          const fieldsWithValues = randomFields.reduce((acc, field) => {
            if (field === "year") {
              acc[field] = getRandomYear();
            } else {
              acc[field] = getRandomCharacter();
            }
            return acc;
          }, {});

          return {
            includeYear: true,
            randomFields: fieldsWithValues,
            randomOffset,
            randomLimit,
          };
        } else {
          // Scenario B: Exclude the year and choose one or two criteria randomly
          const randomFieldsCount = getRandomNumberInRange(1, 2); // Choose 1 or 2 fields without the year
          const randomFields = getRandomFields(randomFieldsCount);
          const randomOffset = getRandomOffset();
          const randomLimit = getRandomLimit();

          const fieldsWithValues = randomFields.reduce((acc, field) => {
            acc[field] = getRandomCharacter();
            return acc;
          }, {});

          return {
            includeYear: false,
            randomFields: fieldsWithValues,
            randomOffset,
            randomLimit,
          };
        }
      };

      const getRandomScenario = () => {
        const scenarios = [
          "yearOnly",
          "yearWithCriteria",
          "noYearWithCriteria",
        ];
        return scenarios[Math.floor(Math.random() * scenarios.length)];
      };

      const getRandomNumberInRange = (min, max) => {
        return Math.floor(Math.random() * (max - min + 1)) + min;
      };
      const getRandomFields = (count) => {
        const fields = ["track", "artist", "album", "genre", "isrc"];
        const randomFields = [];

        for (let i = 0; i < count; i++) {
          const randomField = fields[Math.floor(Math.random() * fields.length)];
          randomFields.push(randomField);
        }

        return randomFields;
      };
      const addTracksToPlaylist = async (
        accessToken,
        playlistId,
        numberOfSongs
      ) => {
        const playlistUrl = `https://api.spotify.com/v1/playlists/${playlistId}/tracks`;
        const addedSongs = [];

        while (addedSongs.length < numberOfSongs) {
          const remainingSongs = numberOfSongs - addedSongs.length;
          const tracksToAdd = Math.min(remainingSongs, BATCH_SIZE);
          const trackBatch = [];

          for (let i = 0; i < tracksToAdd; i++) {
            let trackUri;

            // Continue searching until a valid track is found
            while (!trackUri) {
              const randomYear = getRandomYear();
              trackUri = await searchTrackAndAddToPlaylist(
                accessToken,
                playlistUrl,
                addedSongs
              );
            }

            trackBatch.push(trackUri);
          }

          // Batch addition of tracks to the playlist
          await addBatchToPlaylist(accessToken, playlistUrl, trackBatch);

          // Introduce a delay between batches to avoid rate limits
          await new Promise((resolve) => setTimeout(resolve, searchDelay));
        }

        // Display added songs information
        addedSongsDiv.classList.remove("hidden");
        displayAddedSongsInfo(addedSongs);
      };

      const addBatchToPlaylist = async (
        accessToken,
        playlistUrl,
        trackBatch
      ) => {
        try {
          const addResponse = await fetch(playlistUrl, {
            method: "POST",
            headers: {
              Authorization: `Bearer ${accessToken}`,
              "Content-Type": "application/json",
            },
            body: JSON.stringify({
              uris: trackBatch,
            }),
          });

          if (addResponse.ok) {
            console.log(
              `${trackBatch.length} tracks added to the playlist successfully`
            );
          } else {
            const errorMessage = `Error adding batch to the playlist: ${addResponse.statusText}`;
            console.error(errorMessage);
            // Run an alert if batch adding fails
            alert(errorMessage);
          }
        } catch (error) {
          const errorMessage = `Error adding batch to the playlist: ${error.message}`;
          console.error(errorMessage);
          // Run an alert if batch adding fails
          alert(errorMessage);
        }
      };
      const displayAddedSongsInfo = (addedSongs) => {
        const uniqueAddedSongs = [];
        const uniqueUris = new Set();
        addedSongs.forEach((song) => {
          if (!uniqueUris.has(song.uri)) {
            uniqueUris.add(song.uri);
            uniqueAddedSongs.push(song);
          }
        });

        addedSongsDiv.innerHTML += `<p><strong>Added Songs:</strong></p>`;

        uniqueAddedSongs.forEach((song) => {
          addedSongsDiv.innerHTML += `<p>${song.artist} - ${song.name} | ${song.album}, ${song.year}  (${song.uri})</p>`;
        });

        // Scroll to the top to show the latest added songs
        addedSongsDiv.scrollTop = 0;
      };

      const getPlaylistTracks = async (accessToken, playlistTracksUrl) => {
        const tracksPerPage = 100; // Spotify API returns up to 100 tracks per request
        let allPlaylistTracks = [];
        logToConsole("Playlist found - reading tracks...");
        try {
          let offset = 0;
          let hasNextPage = true;

          while (hasNextPage) {
            const response = await fetch(
              `${playlistTracksUrl}?offset=${offset}&limit=${tracksPerPage}`,
              {
                headers: {
                  Authorization: `Bearer ${accessToken}`,
                },
              }
            );

            if (!response.ok) {
              throw new Error(
                `Error fetching playlist tracks: ${response.status} ${response.statusText}`
              );
            }

            const data = await response.json();
            const currentTracks = data.items.map((item) => item.track);

            if (currentTracks.length > 0) {
              allPlaylistTracks = allPlaylistTracks.concat(currentTracks);
              offset += tracksPerPage;
            } else {
              hasNextPage = false;
            }

            // Introduce a delay between requests
            await new Promise((resolve) => setTimeout(resolve, searchDelay));
          }

          // Update the global playlistTracks array with a single array
          playlistTracks = allPlaylistTracks;

          // Add playlist track URIs to the array of tracks added during runtime
          addedDuringRuntime = addedDuringRuntime.concat(
            allPlaylistTracks.map((playlistTrack) => playlistTrack.uri)
          );

          console.log("Updated playlistTracks:", playlistTracks);

          return allPlaylistTracks;
        } catch (error) {
          console.error("Error fetching all playlist tracks:", error);
          throw error;
        }
      };

      const searchPlaylist = async (accessToken, playlistName) => {
        let offset = 0;
        let playlist = null;
        logToConsole("Getting playlist...");
        try {
          while (!playlist) {
            const searchUrl = `https://api.spotify.com/v1/me/playlists?limit=50&offset=${offset}`;

            logToConsole(`Searching for playlists at offset ${offset}`);
            const response = await fetch(searchUrl, {
              headers: {
                Authorization: `Bearer ${accessToken}`,
              },
            });

            console.log("Received response:", response);

            if (!response.ok) {
              throw new Error(
                "Error fetching playlists: " +
                  response.status +
                  " " +
                  response.statusText
              );
            }

            const data = await response.json();
            console.log("Received JSON data:", data);

            // Add this line to log the playlists found
            console.log("Playlists found:", data.items);

            playlist = data.items.find((item) => item.name === playlistName);

            if (!playlist && data.next) {
              offset += 50;
              await new Promise((resolve) => setTimeout(resolve, searchDelay));
            } else if (!playlist) {
              // If playlist is still not found and there are no more results
              playlist = await createPlaylist(accessToken, playlistName);
              logToConsole("Playlist not found, creating a new one.");
            } else {
              break;
            }
          }

          if (playlist) {
            // Fetch and store the playlist tracks once
            playlistTracks = await getPlaylistTracks(
              accessToken,
              playlist.tracks.href
            );
          }

          console.log("Found playlist:", playlist);
          logToConsole("Adding songs");

          return playlist;
        } catch (error) {
          console.error("Error searching playlist:", error);
          alert("An error occurred while searching for the playlist: " + error);
          logToConsole("An error occurred while searching for the playlist");

          throw error;
        }
      };

      const createPlaylist = async (accessToken) => {
        const createPlaylistUrl = "https://api.spotify.com/v1/me/playlists";

        const response = await fetch(createPlaylistUrl, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${accessToken}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify({
            name: "Random Songs from All of Spotify",
            public: true,
          }),
        });

        const data = await response.json();
        return data;
      };

      const createPlaylistAndAddTracks = async () => {
        if (!isAuthenticated()) {
          redirectToAuthorization();
          return;
        }

        const params = new URLSearchParams(window.location.hash.substring(1));
        const accessToken = params.get("access_token");

        // Notify the user that the process is running
        alert(
          "This may take a minute. Close this alert to begin, and then leave this page open. An alert will run when the process is complete or if there's a fatal error. Check console for more details."
        );
        document.getElementById(
          "createPlaylistAndAddTracksButton"
        ).disabled = true;
        const copyResultsButton = document.getElementById("copyResultsButton");

        // Define variables for the animation
        let dots = 0;
        const maxDots = 3;
        let animationInterval;

        // Function to start the animation
        const startAnimation = () => {
          animationInterval = setInterval(() => {
            dots = (dots + 1) % (maxDots + 1);
            const dotsText = ".".repeat(dots);
            copyResultsButton.innerText = `Processing${dotsText}`;
          }, 500); // Change the interval as needed (500 milliseconds in this example)
        };

        // Start the animation
        startAnimation();

        try {
          const playlist = await searchPlaylist(
            accessToken,
            "Random Songs from All of Spotify"
          );
          const playlistId = playlist
            ? playlist.id
            : (await createPlaylist(accessToken)).id;

          await addTracksToPlaylist(accessToken, playlistId, NUMBER_OF_SONGS);

          // Success: Update HTML elements
          document.getElementById("copyResultsButton").innerText =
            "Results (click to copy to clipboard)";
          clearInterval(animationInterval);
          // Log all queries and tracks
          logAllQueriesAndTracks();
        } catch (error) {
          console.error("An error occurred:", error);
          alert("An error occurred: " + error.message);

          // Error: Update HTML elements
          document.getElementById("copyResultsButton").innerText =
            "Error occurred. Please try again.";
        } finally {
          // Enable the button
          document.getElementById(
            "createPlaylistAndAddTracksButton"
          ).disabled = false;

          // Display "Done running" alert
          alert("Done running.");
        }
      };

      document.addEventListener("DOMContentLoaded", () => {
        const loginButton = document.getElementById("loginButton");

        if (loginButton) {
          loginButton.addEventListener("click", () => {
            redirectToAuthorization();
          });
        } else {
          console.error('Button with id "loginButton" not found.');
        }
      });

      const updateLoginStatus = () => {
        const loginButton = document.getElementById("loginButton");
        const buttonsContainer = document.getElementById("buttons-container");

        if (loginButton && buttonsContainer) {
          if (isAuthenticated()) {
            // User is logged in
            loginButton.innerText = "Logged In";
            loginButton.disabled = true; // Optionally disable the button
            buttonsContainer.classList.remove("hidden");
          } else {
            // User is not logged in
            loginButton.innerText = "Log In to Spotify";
            loginButton.disabled = false;
            buttonsContainer.classList.add("hidden");
          }
        }
      };

      updateLoginStatus();

      const button = document.getElementById(
        "createPlaylistAndAddTracksButton"
      );
      if (button) {
        button.addEventListener("click", createPlaylistAndAddTracks);
      } else {
        console.error(
          'Button with id "createPlaylistAndAddTracksButton" not found.'
        );
      }

      const logToConsole = (message) => {
        console.log(message); // Log to the browser console
        consoleDiv.innerHTML += `<p>${message}</p>`;
      };
      const logAllQueriesAndTracks = () => {
        console.log("All Queries and Tracks:");

        // Convert allQueriesAndTracks to JSON format
        const jsonFormat = JSON.stringify(allQueriesAndTracks, null, 2);
        console.log(jsonFormat);
      };
      // Copy results to clipboard when the button is clicked
      const copyResultsButton = document.getElementById("copyResultsButton");
      copyResultsButton.addEventListener("click", () => {
        const addedSongsDiv = document.getElementById("added-songs");
        const textToCopy = addedSongsDiv.innerText;

        const tempTextarea = document.createElement("textarea");
        tempTextarea.value = textToCopy;
        document.body.appendChild(tempTextarea);
        tempTextarea.select();
        document.execCommand("copy");
        document.body.removeChild(tempTextarea);
      });
    </script>
  </body>
</html>
